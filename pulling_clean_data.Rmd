---
title: "Modeling_Invasive_Species"
author: "Hoang Le Xuan"
date: "2024-01-15"
output: html_document
---

Source for: https://cran.r-project.org/web/packages/CoordinateCleaner/vignettes/Cleaning_GBIF_data_with_CoordinateCleaner.html
#Cleaning GBIF Data source

```{r setup, include=FALSE}

#install.packages("devtools")
library(devtools)
#install_github("ropensci/CoordinateCleaner")
```

```{r}
library(countrycode)
library(vctrs)
library(CoordinateCleaner)
library(dplyr)
library(ggplot2)
library(rgbif)
library(sf)
```


```{r}
#obtain data from GBIF via rgbif
dat <- occ_search(scientificName = "Rhinella marina", 
                  limit = 60000, 
                  hasCoordinate = TRUE)

dat <- dat$data

#names(dat) # a lot of columns

# select columns of interest
dat <- dat %>%
  dplyr::select(species, decimalLongitude, 
                decimalLatitude, countryCode, individualCount,
                gbifID, family, taxonRank, coordinateUncertaintyInMeters,
                year, basisOfRecord, institutionCode, datasetName)

# remove records without coordinates
dat <- dat %>%
  filter(!is.na(decimalLongitude)) %>%
  filter(!is.na(decimalLatitude))
```

## 2.3 Visualize the data on a map


```{r}
#plot data to get an overview
wm <- borders("world", colour = "gray50", fill = "gray50")
ggplot() +
  coord_fixed() +
  wm +
  geom_point(data = dat,
             aes(x = decimalLongitude, y = decimalLatitude),
             colour = "darkred",
             size = 0.5) +
  theme_bw()
```

```{r}
#convert country code from ISO2c to ISO3c
dat$countryCode <-  countrycode(dat$countryCode, 
                                origin =  'iso2c',
                                destination = 'iso3c')

#flag problems
dat <- data.frame(dat)
flags <- clean_coordinates(x = dat, 
                           lon = "decimalLongitude", 
                           lat = "decimalLatitude",
                           countries = "countryCode",
                           species = "species",
                           tests = c("capitals", "centroids",
                                    "equal", "zeros", "countries")) # most test are on by default
## Testing coordinate validity
## Flagged 0 records.
## Testing equal lat/lon
## Flagged 0 records.
## Testing zero coordinates
## Flagged 0 records.
## Testing country capitals
## Flagged 36 records.
## Testing country centroids
## Flagged 1 records.
## Testing country identity
## Flagged 314 records.
## Flagged 350 of 5000 records, EQ = 0.07.
summary(flags)
plot(flags, lon = "decimalLongitude", lat = "decimalLatitude")
```

Alternatively, you can run all tests implemented in CoordinateCleaner with a individual function and connect them using the magrittr pipe operator, which will directly result in a data.frame comprising only cleaned records.


```{r}

#Exclude problematic records
dat_cl <- dat[flags$.summary,]

#The flagged records
dat_fl <- dat[!flags$.summary,]

# To avoid specifying it in each function
names(dat)[2:3] <- c("decimalLongitude", "decimalLatitude")

clean <- dat %>%
  cc_val() %>%
  cc_equ() %>%
  cc_cap() %>%
  cc_cen() %>%
  cc_coun(iso3 = "countryCode") %>%
  cc_sea() %>%
  cc_zero() %>%
  cc_outl() %>%
  cc_dupl()

#In this way, you can also add the individual test results as columns to your initial data.frame:

dat %>%
    as_tibble() %>% 
    mutate(val = cc_val(., value = "flagged"),
           sea = cc_sea(., value = "flagged"))

flags <- cf_age(x = dat_cl,
                lon = "decimalLongitude",
                lat = "decimalLatitude",
                taxon = "species", 
                min_age = "year", 
                max_age = "year", 
                value = "flagged")
# Testing temporal outliers on taxon level
# Flagged 0 records.

dat_cl <- dat_cl[flags, ]


```
## 3 Improving data quality using GBIF meta-data
A histogram of the coordinate precision in the dataset..

```{r}
#Remove records with low coordinate precision
dat_cl %>% 
  mutate(Uncertainty = coordinateUncertaintyInMeters / 1000) %>% 
  ggplot(aes(x = Uncertainty)) + 
  geom_histogram() +
  xlab("Coordinate uncertainty in meters") +
  theme_bw()
```

```{r}
dat_cl_removed <- dat_cl %>%
  filter(coordinateUncertaintyInMeters / 1000 <= 100 | is.na(coordinateUncertaintyInMeters))

# Remove unsuitable data sources, especially fossils 
# which are responsible for the majority of problems in this case
table(dat$basisOfRecord)
```

```{r}
#Individual count
table(dat_cl_removed$individualCount)

dat_cl_removed <- dat_cl_removed %>%
  filter(individualCount > 0 | is.na(individualCount)) %>%
  filter(individualCount < 99 | is.na(individualCount)) # high counts are not a problem
```

```{r}
#Age of records
table(dat_cl_removed$year)

#then remove the age before ww2
dat_cl_removed <- dat_cl_removed %>%
  filter(year > 1945) # remove records from before second world war

table(dat_cl_removed$year)
```

```{r}
## 
## Bufonidae 
##    
dat_cl <- dat_cl_removed %>%
  filter(family == 'Bufonidae')

table(dat_cl_removed$taxonRank) # this is also good
```

## 4 Improving data quality using external information
exclude based on study area, for example lion don't live in high altitude. Consider incorporating into our study
```{r}
#exclude based on study area, for example lion don't live in high altitude. Consider incorporating into our study
#dat_fin <- filter(dat_cl, decimalLatitude < 40)
```

## 5 Identifying problematic data sets
test for erroneous data conversion due to the misinterpretation of the degree sign as decimal delimiter.
You can control the output of the function via the value argument.
```{r}
out.ddmm <- cd_ddmm(dat_cl, lon = "decimalLongitude", lat = "decimalLatitude", 
                    ds = "species", diagnostic = T, diff = 1,
                    value = "dataset")
```

### 5.2 Test for rasterized sampling

use the cd_round function to identify datasets with a significant proportion of coordinates that have been collected in large scale lattice designs. These records might have a low precision and might therefore be problematic for some analyses. For instance presence derived from a 1 degree grid of a national atlas might be to coarse for small scale species distribution models.
```{r}
par(mfrow = c(2,2), mar = rep(2, 4))
out.round <- cd_round(dat_cl, lon = "decimalLongitude", 
                      lat = "decimalLatitude", 
                      ds = "species",
                      value = "dataset",
                      T1 = 7,
                      graphs = T)
```

```{r}
write.csv(dat_cl, "data/dat_cl_Rhinella_marina.csv")

```
